% package inclusion does not work, need to figure this out
% \usepackage{url}

% macros for comments
\newcommand{\maren}[1]{{\color{cyan} \textbf{[Maren: #1]}}}
\newcommand{\andrei}[1]{{\color{red} \textbf{[Andrei: #1]}}}
\newcommand{\rev}[1]{{\color{blue} \textbf{#1}}}

\section{Introduction \label{introduction}}


\maren{Regarding the title of the paper: The UQ comes from the model backend and not from Emukit. Emukit takes a model that is capable of some kind of UQ and uses this capability for active data selection. So Emukit `actifies' the model, yielding an active learning method. The title may suggest that Emukit provide models with UQ capability which is does not. Thoughts on this?}

A few general words about ML, statistical emulation, UQ, and software for those.

\andrei{Testing out macroses}

\maren{Let's also briefly introduce and summarize the unique features of Emukit here. These are
  \begin{itemize}
  \item Model agnosticism 
  \item Using same model for different purposes
  \item Flexibility (quick prototyping)
  \item ...
  \end{itemize}
These should/could then be elaborated on later, perhaps in dedicated subsection with example code.
}

\section{Background on UQ methods}
Here we should give a quick intro into BayesOpt, BQ, design of experiments. Also maybe GPs and multi-fidelity modelling.

\section{Emukit workflow}
The typical workflow for users of Emukit is as follows (see Figure~\ref{figure:workflow} for a graphical description):

\textbf{Build the model.} Instead of constraining the user to certain model classes, Emukit provides the flexibility of using user-specified models. Generally speaking, Emukit does not provide modelling capabilities, instead, expecting users to define their own models. Because of the variety of modelling frameworks available, Emukit does not mandate or make any assumptions about a particular modelling technique or a library, and suggests to implement a subset of defined model interfaces that are required to use a particular method.

\textbf{Run the method.} This is the main focus of Emukit. Emukit defines a general structure of a decision making method and offers implementations of several such methods: Bayesian optimization, Bayesian quadrature, experimental design, and sensitivity analysis. All methods in Emukit toolkit are model-agnostic and defining new APIs to accommodate other frameworks is easy.

\textbf{Solve the task.} For the end users, Emukit is a way to solve a certain task, which may have research or business value. Emukit comes with a set of examples of how tasks such as hyper-parameter tuning, sensitivity analysis multi-fidelity modelling or benchmarking are accomplished using the library.

\begin{figure}[h]
    \centering
      \includegraphics[scale=0.4]{workflow.png}  
    \caption{Summary of workflow for the users of Emukit. A model is computed in modelling framework of choice. The model is wrapped using a pre-defined interface and connected to the core components of several methods such as Bayesian optimization, experimental design etc. Specific tasks are then solved using these methods.}
    \label{figure:workflow}
\end{figure}

\subsection{Architecture of the Emukit package}
\maren{Can we rename the section title to package design or sth like this? To a ML researcher `design' would be the node design. (I know these are not ML proceedings but it's still confusing)}
\andrei{Sure thing, renamed, although this is probably not ideal either.}

At a conceptual level the methods supported in Emukit -- such as Bayesian optimisation, experimental design and quadrature -- are all cyclic decision making processes that follow a similar pattern.\maren{It may be good to simply use the defined names `Bayesian optimization' and `Bayesian quadrature' as not all optimization or quadrature methods are Bayesian. Also, it is not true that e.g., all Bayesian quadrature methods and all exp design methods are cyclic (it is true for BO though). The term Bayesian learning methods seems a bit ill-suited. We could perhaps talk about active learning/active point selection for probabilistic models (some of which are Bayesian).} \andrei{Fair enough, I just invented something on the go. But it would be very convenient to have a collective name.}
Algorithmically they can be thought of as instances of a common abstract loop, which we now describe (also described by Algorithm \ref{alg:emukit_loop}).

The common goal of all these methods is to learn a behavior of an \textit{objective function} - a black box expensive process that has certain \textit{parameters}. The knowledge about the objective function (initially available as well as that collected during the learning process) is represented with a \textit{probabilistic model}. A mechanism employed to propose new data points to evaluate the objective at is called an \textit{acquisition function}. Finally, the decision making process is done in a \textit{loop} until a certain \textit{stopping condition} is met. 

\andrei{Still struggling to understand how to add commands to the preamble, could be that the template doesn't allow that at all. That's limiting, e.g. we cannot use packages for algorithms.}\maren{That's annoying. If there is no solution we can compile the code in another tex file and include a figure of the pseudo-code.}
% Algorithm is taken from the original NeurIPS workshop paper
% \begin{algorithm}
    % \While{stopping condition is not met}{
    %     collect next point(s) for evaluation\;
    %     evaluate objective function\;
    %     update model with new observation(s)\;
    % }
    % \caption{Decision making loop in Emukit}
    % \label{alg:emukit_loop}
% \end{algorithm}

The internal structure of Emukit reflects these abstractions to ensure that fundamental components of the decision making loop could be swapped out and replaced. While some of the basic components in Emukit correspond to the parts of the Bayesian decision making loop exactly, others are more fine-grained to allow for greater flexibility and plug-and-play experience for the researchers using the package. We will now give an overview of these components.

\andrei{Below is largely based on our documentation}
\textbf{Outer Loop}. The \texttt{emukit.core.loop.OuterLoop} class is the abstract loop where the different components come together. Loops for specific methods, such as Bayesian optimisation and experiment design, should subclass it.

\textbf{Parameter space}. Represents parameter space of the objective function. Emukit supports continuous, categorical, discrete, and bandit parameters.

\textbf{Model}. All Emukit loops need a probabilistic model. Emukit does not provide functionality to build models as there are already good modelling frameworks available in Python. Instead, it provides a way of interfacing third part modelling libraries. The interfacing mechanism consists of two parts: interfaces and wrappers. \textit{Interfaces} define functionality required from a model Different models and modelling frameworks will provide different functionality. For instance a Gaussian process will usually have derivatives of the predictions available but random forests will not. These different functionalities are represented by a set of interfaces which a model implements. The basic interface that all models must implement is \texttt{IModel}, which implements functionality to make predictions and update the model but a model may implement any number of other interfaces such as \texttt{IDifferentiable} which indicates a model has prediction derivatives available. Interfaces can also be defined by other components of the decision making loop to indicate that a certain functionality is required from the model. For example, \texttt{ICalculateVarianceReduction} defines methods the user needs to implement with their model to use it with the vadirance reduction technique. \texttt{Model wrappers} adopt third-party models and implement one or more of the interfaces using specific modelling framework. Emukit provides a wrapper for using a model created with \texttt{GPy} \cite{gpy2014}.
\maren{I find the interface capability of Emukit quite unique and a real selling point. It somehow gets lost a bit in between the lines. Shall we make a separate section called `model interfaces' or `custom backends' or sth similar with an example and simply mention here briefly that models are big interfaced?}

\textbf{Candidate Point Calculator}. This entity drives the decision on which point(s) to evaluate next. The simplest implementation provided out of the box, \texttt{SequentialPointCalculator}, collects one point at a time by finding where the acquisition is at a maximum by applying the acquisition optimiser to the acquisition function. More complex implementations are possible, for example to enable batches of points to be collected so that the user function can be evaluated in parallel.

\textbf{Acquisition}. The acquisition is a function defined on the parameter space that produces continuous values. It represents a heuristic quantification of how valuable collecting a future point might be, and produces continuous values.It is used by the candidate point calculator to decide which point(s) to collect next. Acquisition functions balance exploration and explotation of the decision making process.

\textbf{Acquisition Optimizer}. The \texttt{AcquisitionOptimizer} optimizes the acquisition function to find the point at which the acquisition is at a maximum. If available, the optimizer can use the acquisition function gradients. Otherwise, it will either estimate the gradients numerically, or use a gradient free optimisation.

\textbf{User Function}. This is the component that represents the objective function. It can be evaluated by the user, or it can be passed into the loop and evaluated by Emukit.

\textbf{Model Updater}. The \texttt{ModelUpdater} class updates the model with new training data after a new point is observed and optimizes any hyper-parameters of the model. It can decide whether hyper-parameters need updating based on some internal logic.

\textbf{Stopping Condition}. The \texttt{StoppingCondition} class chooses when the decision making loop should stop collecting points. The most commonly used example is to stop when a set number of iterations have been reached.

These are the core components Emukit defines. Specific methods can also define additional concepts of their own, e.g. integration measures or cost. Table \ref{table:abstraction_mapping} shows the mapping between Bayesian decision making abstractions and Emukit components.

\begin{table}
    \setlength{\DUtablewidth}{\tablewidth}
    \begin{longtable}[c]{p{0.4\DUtablewidth}p{0.4\DUtablewidth}}
        \toprule
        \textbf{Bayesian decision making abstractions} & \textbf{Emukit components} \\
        \midrule
        \endfirsthead
        Loop & Outer loop \\
        \midrule
        Parameters & Parameter space \\
        Probabilistic model & Model interface \\
        & Model wrapper \\
        \midrule
        Acquisition function & Candidate Point Calculator \\
        & Acquisition \\
        & Acquisition optimiser \\
        \midrule
        Objective function & User function \\
        & Model Updater \\
        \midrule
        Stopping Condition & Stopping condition \\
        \bottomrule
    \end{longtable}
    \caption{The mapping between abstractions of the Bayesian deciion making process and the components defined in Emukit.}
    \label{table:abstraction_mapping}
\end{table}

\section{Methods}

\maren{May it be useful to introduce each of the methods (BO, BQ, ExpDesign) with some minimal example code similarly to the webpage? }

\section{Usage and Adoption}
\andrei{I am not sure if we actually want to talk about adoption}
Here we discuss how Emukit can be used and and why. We can talk about GPSS, ML for Physical World course, Freiburg course by Aaron Klein (at some point it was the case). \maren{If it's just stuff that in some way relates to the original authors I would not do that.}

\andrei{But this idea i like more}
WOuld be nice to maybe discuss concrete examples of problems solved with Emukit. Maybe a quick overview of citing papers, or maybe pick 2-3 and go deep into use cases? \maren{that sounds good.}

\section{Limitations}
We can be open about limitations: no auto-diff, manual gradients, no easy GPU support. Explain that most of these stem from being model agnostic.

\section{Related work}
Here we talk about related packages: GPyOpt \cite{gpyopt2016}, BoTorch \cite{balandat2020botorch}, Trieste \cite{picheny2023trieste}. Probably not worth covering related work on every method we do.

\section{Conclusion}
we conclude the paper. maybe future work goes here? we don't have anything big planned

\section{Acknowledgments}
MM gratefully acknowledges financial support by the European Research Council through ERC StG Action 757275 / PANAMA; the DFG Cluster of Excellence “Machine Learning - New Perspectives for Science”, EXC 2064/1, project number 390727645; the German Federal Ministry of Education and Research (BMBF) through the T\"{u}bingen AI Center (FKZ: 01IS18039A); and funds from the Ministry of Science, Research and Arts of the State of Baden-W\"{u}rttemberg.
